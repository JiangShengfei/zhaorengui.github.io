#+TITLE:  php-cross-domain 
#+AUTHOR:    zrg
#+EMAIL:     zrg1390556487@gmail.com
#+LANGUAGE:  cn
#+OPTIONS:   H:3 num:nil toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:plain toc:t ltoc:t mouse:underline buttons:0 path:http://cs3.swfc.edu.cn/~20121156044/.org-info.js />
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://cs3.swfu.edu.cn/~20121156044/.org-manual.css" />
#+EXPORT_SELECT_TAGS: export
#+HTML_HEAD_EXTRA: <style>body {font-size:14pt} code {font-weight:bold;font-size:12px; color:darkblue}</style>
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 
#+XSLT: 

#+STARTUP: showall indent
#+STARTUP: hidestars
#+BEGIN_EXPORT HTML
---
layout: post
title:  PHP 跨域问题解决
author: zrg
description: PHP 跨域问题
excerpt: 
comments: false
categories: 
- php
tags:
- 跨域
---
#+END_EXPORT

# (setq org-export-html-use-infojs nil)
感谢您阅读此文，如果您发现任何错误，请发邮件至 zrg1390556487@gmail.com，谢谢！
# (setq org-export-html-style nil)

* 问题概述
: 现代浏览器针对不同域名之间的ajax请求，一般情况下会阻止你获取到ajax返回内容（即使是1.a.com和2.a.com也算跨域）。
* Ajax 请求跨域问题解决
** Client
#+CAPTION: 客户端请求代码
#+BEGIN_SRC emacs-lisp
// 上传文件
function upload_idcard_file(_this,type){
	var formData = new FormData();
	formData.append('type',type);
	formData.append('file',_this.files[0]);
	$.ajax({
		url: '{$upload_file_url}',
	    type: 'POST',
		dataType: 'json',
		data: formData,
		cache: false,
		contentType : false,
		processData : false,
		headers : {"access_token" : "{$access_token}"},
		success:function(d){
			var img_url = d.data;
			img_url = 'http:'+img_url;
			load_img(_this.id,img_url);
	    },
		error:function(err){
			//
	    }
	});
}
#+END_SRC
** Server
*** 解决方式一
#+CAPTION: 粗糙解决方式
#+BEGIN_SRC emacs-lisp
// 允许所有跨域请求
header('Access-Control-Allow-Origin: *');
// 只允许http://www.baidu.com下发来的跨域请求
// header('Access-Control-Allow-Origin: http://www.baidu.com');
// 设置支持的http请求方式
header('Access-Control-Allow-Methods:POST,GET,OPTIONS,PUT,DELETE');
// 响应头 请按照自己需求添加
header('Access-Control-Allow-Headers:access_token'); 
#+END_SRC
*** 解决方式二
: 方式一中单纯使用*或者具体域名，在开发接口时显得不太科学，这时候我们需要进行动态的判断处理。
#+CAPTION: 动态判断处理跨域问题
#+BEGIN_SRC emacs-lisp
if(isset($_SERVER['HTTP_ORIGIN'])){
	// 请求方法
        $request_method = $_SERVER['REQUEST_METHOD'];
        // 定义一个允许跨域请求接口的域名列表，这里你可以用配置也可以用其它形式，我这里只是用$GLOBALS简单演示一下
        $allow_origin = array(
        	'baidu.com',
                'bing.com'
        );
	// 判断是否有origin请求头
        if(in_array($request_method, $allow_origin)
        {
		header('Access-Control-Allow-Origin: ' . $_SERVER['HTTP_ORIGIN']);
          break;
        }
    }
}
#+END_SRC
* Session 跨域问题解决
#+BEGIN_SRC emacs-lisp
ini_set('session.cookie_domain', '.a.com');
header('Access-Control-Allow-Credentials: true');
#+END_SRC
